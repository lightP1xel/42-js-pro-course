# Структуры данных
## Для начала работы потребуется:
`npm install` - установка всех зависимостей

`npm run test` - запуск тестов и проверка результатов

## Задание
Есть написанные тесты которые проверяют некоторую функциональность. Нужно сделать так, чтобы тесты выполнялись успешно. Так же можно дополнить тесты, если текущих недостаточно.

### 1. quickSort
Метод `.sort` в Javascript сортирует массив по алгоритму QuickSort. Но этот метод изменяет оригинальный массив.

Нужно написать свою реализацию [быстрой сортировки](https://ru.wikipedia.org/wiki/%D0%91%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0) которая бы не изменяла оригинальный массив

### 2. binarySearch
Поиск по массиву стандартными средствами Javascript имеют быстродействие O(n).
 Иногда требуется находить элементы в очень больших массивах, поэтому нужно разработать алгоритм поиска который бы искал элемент за O(log n). Для этого подойдёт [бинарный поиск](https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA)

### 3. toFlat
Максимальная глубина рекурсии ограничена движком JavaScript. Точно можно рассчитывать на 10000 вложенных вызовов, некоторые интерпретаторы допускают и больше, но для большинства из них 100000 вызовов – за пределами возможностей.

Любая рекурсия может быть переделана в цикл. Как правило, вариант с циклом будет эффективнее.
 
Нужно написать код, который бы работал для глубоко-вложенных массивов > 10000 уровня вложенности (без рекурсии) и преобразовывал его в массив с плоской структурой
```
toFlat([[[[5, 4], 2], 1], 3]) => [5, 4, 2, 1, 3]
```

### 4. HashTable
Нужно написать хэш-таблицу для хранения работников. Хэш-функция должна конвертировать символ `value.name[0]` в charCode
